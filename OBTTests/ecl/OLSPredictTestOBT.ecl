/*##############################################################################
    
    HPCC SYSTEMS software Copyright (C) 2022 HPCC SystemsÂ®.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
       
       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
############################################################################## */

#ONWARNING(4550, ignore);

// This is the OLSPredict file from the test folder with
// changes that include a different way of determining and 
// presenting the result, and comment/constant name changes

// This module provides different levels of Linear Regression using the OLS module
// and verifies that they can predict new values that are generated by a linear
// formula.
// It works off synthetic data that is generated by a linear formula with noise.

IMPORT LinearRegression AS LR;
IMPORT ML_Core;
IMPORT ML_Core.Types AS MLTypes;
IMPORT PBblas;
IMPORT PBBlas.test.MakeTestMatrix AS TM;
IMPORT PBBlas.Types as PBBTypes;
IMPORT PBBlas.Converted as Converted;
IMPORT Python3;

LayoutCell := PBBTypes.Layout_Cell;
NumericField := MLTypes.NumericField;

PTwo31 := POWER(2, 31);

REAL Noise := FUNCTION
  out := ((RANDOM()-PTwo31)%1000)/10000;
  return out;
END;

TestResult := RECORD
  STRING50 TestName;
  SET OF REAL X;
  REAL Y_indx := 1; // Which Y we are comparing when doing multi-variate
  REAL Y;
  REAL projY;
  REAL diff;
  REAL pctErr;
END;

// TEST 1 -- Simple Linear Regression

Slope1 := 3.123; 
Intercept1 := -1.222;
N1 := 10000;
M1 := 1;

MatrixX1 := tm.RandomMatrix(N1, M1, 1.0, 1);

LayoutCell makeY(LayoutCell X) := TRANSFORM
  SELF.x := X.x;
  SELF.y := 1;
  SELF.wi_id := X.wi_id;
  SELF.v := Slope1 * X.v + Intercept1 + Noise;
END;

MatrixY1 := PROJECT(MatrixX1, makeY(LEFT));

X1 := Converted.MatrixToNF(MatrixX1);
Y1 := Converted.MatrixToNF(MatrixY1);
OLS1 := LR.OLS(X1, Y1);

NewMatrixX1 := tm.RandomMatrix(50, M1, 1.0, 1);
NewX1 := Converted.MatrixToNF(NewMatrixX1);
PredY1 := OLS1.Predict(newX1);

TestResult formatRslt1(STRING32 tn, NumericField l, NumericField r) := TRANSFORM
  SELF.TestName := tn;
  SELF.X := [l.value];
  SELF.Y := r.value;
  SELF.projY := Slope1 * l.value + Intercept1;
  SELF.diff := SELF.Y - SELF.projY;
  SELF.pctErr := SELF.diff / SELF.projY;
END;

Res1 := JOIN(newX1, predY1, LEFT.id=RIGHT.id, formatRslt1('TEST 1 -- Simple Regression', LEFT, RIGHT));

// TEST 2 -- Multiple Regression

CompX2 := RECORD
  REAL wi;
  REAL id;
  REAL X1;
  REAL X2;
  REAL X3;
END;

CompX2 MakeComposite2(LayoutCell l, DATASET(LayoutCell) r) := TRANSFORM
  SELF.wi := l.wi_id;
  SELF.id := l.x;
  SELF.X1 := r(y=1)[1].v;
  SELF.X2 := r(y=2)[1].v;
  SELF.X3 := r(y=3)[1].v;
END;

Slope2A := -1.8;
Slope2B := -4.333;
Slope2C := 11.13;
Intercept2 := -3.333;
N2 := 10000;
M2 := 3;

MatrixX2 := tm.RandomMatrix(N2, M2, 1.0, 2);

MatrixX2Sorted := SORT(MatrixX2, wi_id, x);
MatrixX2Grouped := GROUP(MatrixX2Sorted, wi_id, x);
MatrixX2Composite := ROLLUP(MatrixX2Grouped, GROUP, makeComposite2(LEFT, ROWS(LEFT)));

LayoutCell makeY2(compX2 X) := TRANSFORM
  SELF.x := X.id;
  SELF.y := 1;
  SELF.wi_id := X.wi;
  SELF.v := Slope2A * X.X1 + Slope2B * X.X2 + Slope2C * X.X3 + Intercept2 + Noise;
END;

MatrixY2 := PROJECT(MatrixX2Composite, makeY2(LEFT));
X2 := Converted.MatrixToNF(MatrixX2);
Y2 := Converted.MatrixToNF(MatrixY2);

OLS2 := LR.OLS(X2, Y2);

NewMatrixX2 := tm.RandomMatrix(50, M2, 1.0, 2);

NewX2 := Converted.MatrixToNF(NewMatrixX2);
PredY2 := OLS2.Predict(newX2);

NewX2Sorted := SORT(NewMatrixX2, wi_id, x);
NewX2Grouped := GROUP(NewX2Sorted, wi_id, x);
NewX2Composited := ROLLUP(NewX2Grouped, GROUP, makeComposite2(LEFT, ROWS(LEFT)));

TestResult formatRslt2(STRING32 tn, compX2 l, NumericField r) := TRANSFORM
  SELF.TestName := tn;
  SELF.X := [l.X1, l.X2, l.X3];
  SELF.Y := r.value;
  SELF.projY := Intercept2 + Slope2A * l.X1 + Slope2B * l.X2 + Slope2C * l.X3;
  SELF.diff := SELF.Y - SELF.projY;
  SELF.pctErr := ABS(SELF.diff / SELF.projY);
END;

DATASET(TestResult) Res2 := JOIN(NewX2Composited, predY2, LEFT.id=RIGHT.id, formatRslt2('TEST 2 -- Multiple Regression', LEFT, RIGHT));

// TEST 3 -- Myriad -- Test 1 and Test 2 simultaneously

OLS3 := LR.OLS(X1 + X2, Y2 + Y1);

PredY3 := OLS3.Predict(NewX2 + NewX1);

PredY31 := PredY3(wi=1);
PredY32 := PredY3(wi=2);

Res3A := JOIN(newX1, Predy31, LEFT.id=RIGHT.id, formatRslt1('TEST 3A -- Myriad(1)', LEFT, RIGHT));
Res3B := JOIN(NewX2Composited, predY32, LEFT.id=RIGHT.id, formatRslt2('TEST 3B -- Myriad(2)', LEFT, RIGHT));

// TEST 4 -- Same as test 3 but with saved model

OLS4 := LR.OLS();

Model4 := OLS3.GetModel;

Predy4 := OLS4.Predict(NewX2 + NewX1, Model4);

PredY41 := predY4(wi=1);
PredY42 := predY4(wi=2);

Res4A := JOIN(NewX1, PredY41, LEFT.id=RIGHT.id, formatRslt1('TEST 4A -- Saved Model(1)', LEFT, RIGHT));
Res4B := JOIN(NewX2Composited, PredY42, LEFT.id=RIGHT.id, formatRslt2('TEST 4B -- Saved Model(2)', LEFT, RIGHT));

// TEST 5 -- Multi-variate regression.  Multiple Y values

CompX5 := RECORD
  REAL wi;
  REAL id;
  REAL number;
  REAL X1;
  REAL X2;
  REAL X3;
END;

CompX5 MakeComposite5(LayoutCell l, DATASET(LayoutCell) r) := TRANSFORM
  SELF.wi := l.wi_id;
  SELF.id := l.x;
  SELF.number := l.y;
  SELF.X1 := r(y=1)[1].v;
  SELF.X2 := r(y=2)[1].v;
  SELF.X3 := r(y=3)[1].v;
END;

// Coefficients for Y1
Slope5Y1A := -1.8;
Slope5Y1B := -4.333;
Slope5Y1C := 11.13;
Intercept5Y1 := -3.333;

// Coefficients for Y2
Slope5Y2A := 2.123;
Slope5Y2B := -7.508;
Slope5Y2C := -1.765;
Intercept5Y2  := 2.654;
N5 := 10000;
M5 := 3;

MatrixX5 := tm.RandomMatrix(N5, M5, 1.0, 1);

X5Sorted := SORT(MatrixX5, wi_id, x);
X5Grouped := GROUP(X5Sorted, wi_id, x);
X5Composited := ROLLUP(X5Grouped,  GROUP, makeComposite5(LEFT, ROWS(LEFT)));

LayoutCell makeY5(compX5 X, UNSIGNED c) := TRANSFORM
  SELF.x := X.id;
  SELF.y := c;
  SELF.wi_id := X.wi;
  v1 := Slope5Y1A * X.X1 + Slope5Y1B * X.X2 + Slope5Y1C * X.X3 + Intercept5Y1 + Noise;
  v2 := Slope5Y2A * X.X1 + Slope5Y2B * X.X2 + Slope5Y2C * X.X3 + Intercept5Y2 + Noise;
  SELF.v := IF(c=1, v1, v2);
END;

MatrixY5 := NORMALIZE(X5Composited, 2, makeY5(LEFT, COUNTER));

X5 := Converted.MatrixToNF(MatrixX5);
Y5 := Converted.MatrixToNF(MatrixY5);

OLS5 := LR.OLS(X5, Y5);

NewMatrixX5 := tm.RandomMatrix(50, M5, 1.0, 1);

NewX5 := Converted.MatrixToNF(NewMatrixX5);
PredY5 := OLS5.Predict(NewX5);

NewX5Sorted := SORT(NewMatrixX5, wi_id, x);
NewX5Grouped := GROUP(NewX5Sorted, wi_id, x);
NewX5Composited := ROLLUP(NewX5Grouped,  GROUP, makeComposite5(LEFT, ROWS(LEFT)));

TestResult formatRslt5(STRING32 tn, compX5 l, NumericField r) := TRANSFORM
  SELF.TestName := tn;
  SELF.X := [l.X1, l.X2, l.X3];
  SELF.Y := r.value;
  SELF.Y_indx := r.number;
  projY1 := Intercept5Y1 + Slope5Y1A * l.X1 + Slope5Y1B * l.X2 + Slope5Y1C * l.X3;
  projY2 := Intercept5Y2 + Slope5Y2A * l.X1 + Slope5Y2B * l.X2 + Slope5Y2C * l.X3;
  SELF.projY := IF(SELF.Y_indx = 1, projY1, projY2);
  SELF.diff := SELF.Y - SELF.projY;
  SELF.pctErr := ABS(SELF.diff / SELF.projY);
END;

DATASET(TestResult) Res5A := JOIN(NewX5Composited(number=1), predY5(number=1), LEFT.id=RIGHT.id, formatRslt5('TEST 5A -- Multi-variate Y1', LEFT, RIGHT));
DATASET(TestResult) Res5B := JOIN(NewX5Composited(number=2), predY5(number=2), LEFT.id=RIGHT.id, formatRslt5('TEST 5B -- Multi-variate Y2', LEFT, RIGHT));

// Combine Results to create evaluation 

Details := Res1 + Res2 + Res3A + Res3B + Res4A + Res4B + Res5A + Res5B;

DetailsSorted := SORT(Details, testname);

// Max allowable difference
Epsilon := .00001;

TestSummary := RECORD
  STRING50 testname := details.testname;
  REAL     maxErr := MAX(GROUP, details.pctErr);
  REAL     avgErr := AVE(GROUP, details.pctErr);
  STRING8  status := IF(AVE(GROUP, details.pctErr) > Epsilon, 'FAIL', 'SUCCESS');
END;

Summary := TABLE(Details, TestSummary, TestName);

// Helper function that gets the names of any tests that fail
SET OF STRING GetFailedTests(DATASET(TestSummary) tests) := EMBED(Python3)
    failedtests = []

    for test in tests:
        status = test.status[:-4]
        if str(status) == "FAIL":
            failedtests.append(test.testname)
  
    return failedtests
ENDEMBED;

FailedTests := GetFailedTests(Summary);

// Only get the information of tests that fail
FailedTestsDetails := DetailsSorted(testname IN FailedTests);

Pass := COUNT(Summary(status = 'FAIL')) = 0;

OUTPUT(IF(Pass, 'Passed All Tests', 'Tests have failed. See FailedDetails for more information'), NAMED('Result'));
OUTPUT(FailedTestsDetails, NAMED('FailDetails'));
